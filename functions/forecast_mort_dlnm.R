########################################
#' forecast_mort_dlnm
#' Function for calculating the fractions attributable to temperatures and the
#' total mortality rates adjusted for the projected temperature effects.
#' @param dem_sc a data.frame containing simulated mortality rates per age
#' @param temp_rcp a data.frame containing future temperatures
#' @param model a object containing the fitted DLNM model
#' @param q_range a 2-dimensional vector with the thresholds related to
#' extreme hot and extreme cold temperature
#' @param sel_effect the temperature effects returned
#' @param nsim the number of simulations
#' @param parallel type of parallelization
#' @param ncpus number of cores to use
#' @param seed set the value of the seed
########################################

forecast_mort_dlnm <- function(dem_sc, temp_rcp, model,
                               q_range = NULL, age_qx = NULL, age_ex  = NULL ,
                               year_breaks = NULL, year_labels = NULL,
                               sel_effect = c("all_effect", "extr_hot_effect"),
                               nsim = 1, parallel = c("no", "snow", "multicore"),
                               ncpus = 1, detail.result = F,
                               seed = 1234)
{
  # sanity check
  parallel <- match.arg(parallel, c("no", "snow", "multicore"))
  if (parallel == "multicore" & .Platform$OS.type == "windows")
  {
    parallel <- "snow"
    warning("As the multicore option is not supported on Windows it was replaced by snow")
  }
  if ((parallel == "snow" | parallel == "multicore") & missing(ncpus))
    stop("You have to specify the number of available processors to parallelize
         the bootstrap")
  if(! is(model, "list"))
  {
    stop("model should be a list generated by fit_dlnm")
  }

  # default values
  if(is.null(q_range))
  {
    q_range[1] <- 0
    q_range[2] <- 25
  } else
  {
    if(length(q_range) != 2) stop("q_range should be of length 2")
  }
  if(is.null(age_qx))
  {
    age_qx <- c(25, 65, 75, 85)
  }
  if(is.null(age_ex))
  {
    age_ex <- c(0, 65)
  }
  if(is.null(year_breaks) | is.null(year_labels))
  {
    year_breaks <- c(1980, 1989, 1999, 2009, 2019, 2029, 2039, 2049, 2059, 2069,
                     2079, 2089, 2100)
    year_labels <- c("1980s", "1990s", "2000s", "2010s", "2020s", "2030s",
                     "2040s", "2050s", "2060s", "2070s", "2080s","2090s")
  }

  # parameters
  n <- length(model)
  age_bucket <- names(model)
  x <- 0 # set by default
  # objects in memory
  vect_import <- c("n", "x", "arg_simu","q_range", "fold_bib", "AGE_MAX")

  # calc life expectancy
  dem_sc <- life_exp_ts(dem_sc, calc_xs = FALSE)

  # Step 1 - Extract list of models, demographic datasets and simulate coefficients
   arg_simu <- lapply(1:n, function(x)
  {
    if(n > 1) # Model per age bucket
    {
      # Select model and people in the age bucket
      temp_model <- model[[x]]
      dem <- dem_sc %>% filter(age_bk == age_bucket[x])
    } else
    {
      temp_model <- model
      # Demography
      dem <- dem_sc
    }
    # Compute bootstrapped coefficients
    if (nsim == 1)
    {
      coef_sim <- NULL
    } else
    {
      set.seed(seed)
      coef_sim <- mvrnorm(nsim, temp_model$coef, temp_model$vcov)
    }

    # Compute attributable fraction
    ## Select different subperiods depending on the level of temperature
    config_temp <-list(
      all_effect = temp_rcp %>% mutate(select_period = 1) %>% dplyr::select(years, datedec, tavg, select_period),
      moderate_hot_effect = temp_rcp %>% mutate(select_period = 1 * (temp_rcp$tavg >  temp_model$cen & temp_rcp$tavg <  q_range[2])) %>% dplyr::select(years, datedec, tavg, select_period),
      moderate_cold_effect = temp_rcp %>% mutate(select_period = 1 * (temp_rcp$tavg <  temp_model$cen & temp_rcp$tavg >  q_range[1])) %>% dplyr::select(years, datedec, tavg, select_period),
      extr_hot_effect = temp_rcp %>% mutate(select_period = 1 * (temp_rcp$tavg >=  q_range[2])) %>% dplyr::select(years, datedec, tavg, select_period),
      extr_cold_effect = temp_rcp %>% mutate(select_period = 1 * (temp_rcp$tavg <=  q_range[1])) %>% dplyr::select(years, datedec, tavg, select_period)
    )
    return(list(
      temp_model = temp_model,
      dem = dem,
      coef_sim = coef_sim,
      config_temp = config_temp
    ))
  })

  # Step 2- Create function for forecasting a population
  # This function is called for each simulation
  forecast_sim <- function(i)
  {
    # Loop on age buckets
    res <- lapply(1:n, function(x){
      # get common arguments
      temp_model <- arg_simu[[x]]$temp_model
      dem <- arg_simu[[x]]$dem
      coef_sim <- arg_simu[[x]]$coef_sim
      config_temp <- arg_simu[[x]]$config_temp

      # Select coefficient related to the simulation
      if(nsim == 1){
        temp_coef <- coef_sim
      } else{
        temp_coef <- coef_sim[i, ]
        dem <- dplyr::filter(dem, sim == i)
      }

      # Extract coefs and compute all temperature effects
      pred_effect <- lapply(names(config_temp), function(k)
      {
        df <- config_temp[[k]]
        pred <- predict_attrib_dlnm(temp_model, newdata = df, coef_sim = temp_coef,
                                    fast = T)$pred_effect

        # Aggregate effects over each year during the projection
        ## We assume the weight associated with the distribution of virtual deaths
        ## is constant.
        pred <- pred %>%
          group_by(years) %>%
          summarise(ewt_attrib_year = sum(ewt_attrib), nb_days = n())
        pred <- pred %>% mutate(attrib_frac = ewt_attrib_year / nb_days)

        # Apply temperature effect on mortality rates
        dem <- dem %>%
          left_join(y = pred, by = c("year" = "years"))
        dem <- na.omit(dem)
        dem <- dem %>% mutate(
          Qxt_xs = 1-exp(-(-log(1-Qxt) * (1 + attrib_frac))),
          attrib_frac = attrib_frac, temp_effect = k
          )
        return(dem)
      })
      pred_effect <- do.call("rbind", pred_effect)
      pred_effect$sim <- i
      pred_effect <- pred_effect %>% relocate(sim, .before = age)
      return(pred_effect)
    })
    if(n > 1)
    {
      res <- do.call("rbind", res)
    }
    # Reorder
    res <- res %>% arrange(temp_effect, sim, year, age)
    ## 1 - Excess of deaths in % and number
    tab_excess <- res %>%
      group_by(temp_effect, sim, year, age_bk) %>%
      summarise(attrib_frac = mean(attrib_frac)) %>%
      dplyr::select(temp_effect, sim, year, age_bk, attrib_frac)

    # Add life expectancy with temperature effects
    ## Remove not used scenario
    res <- res %>%
      dplyr::filter(temp_effect %in% sel_effect)
    res <- life_exp_ts(res, calc_xs = TRUE)
    # Computes main indicators :
    ## 2 - Life expectancy for particular ages
    tab_ex <- do.call("rbind", lapply(age_ex, function(xx){
      res %>%
        filter(age == xx) %>%
        dplyr::select(temp_effect, sim, year, age, Ext, Ext_xs)
    }))
    ## 3 - qx for particular ages
    tab_qx <- do.call("rbind", lapply(age_qx, function(xx){
      res %>%
        filter(age == xx) %>%
        dplyr::select(temp_effect, sim, year, age, Qxt, Qxt_xs)
    }))
    # Configure output
    if(detail.result)
    {
      tab_res <- res
    } else
    {
      res <- NULL
      tab_res <- NULL
    }
    return(list(
      tab_res = tab_res,
      tab_ex = tab_ex,
      tab_qx = tab_qx,
      tab_excess = tab_excess
    ))
  }

  # step 3- run parallel or sequential computation, and aggregate results
  if (parallel != "no" && nsim > 1)
  {
    # Configure parallelization
    if (parallel == "snow") type.par <- "PSOCK"
    else if (parallel == "multicore") type.par <- "FORK"
    if (parallel == "multicore" & .Platform$OS.type == "windows")
    {
      parallel <- "snow"
      warning("As the multicore option is not supported on Windows it was replaced by snow.")
    }
    clus <- parallel::makeCluster(ncpus, type = type.par)
    parallel::clusterExport(clus, vect_import, envir=environment())
    parallel::clusterEvalQ(clus, {
      source(paste(fold_bib,"predict_attrib_dlnm.R",sep=""), encoding = "UTF-8")
      source(paste(fold_bib,"life_exp_ts.R",sep=""), encoding = "UTF-8")
      source(paste(fold_bib,"utils.R",sep=""), encoding = "UTF-8")
      invisible(lapply(c("lubridate", "splines","mgcv", "dlnm", "data.table",
                         "ggplot2","scales","readxl","kableExtra", "dplyr",
                         "tidyr", "mvtnorm", "Rfast",
                         "parallel"), instal.import.package))
    })
    # Run parallel computation
    pred <- try(parallel::parLapply(clus, 1:nsim, forecast_sim))
    if(!inherits(pred, "try-error"))
    {
      # Extract and organize results in a list
      res <- list(
        tab_res = do.call("rbind", lapply(1:nsim, function(i){pred[[i]]$tab_res})),
        tab_ex = do.call("rbind", lapply(1:nsim, function(i){pred[[i]]$tab_ex})),
        tab_qx = do.call("rbind", lapply(1:nsim, function(i){pred[[i]]$tab_qx})),
        tab_excess = do.call("rbind", lapply(1:nsim, function(i){pred[[i]]$tab_excess}))
      )
    }
    parallel::stopCluster(clus)
  } else
  {
    if(nsim == 1)
    {
      pred <- forecast_sim(1)
      res <- list(
        tab_res = pred$tab_res,
        tab_ex = pred$tab_ex,
        tab_qx = pred$tab_qx,
        tab_excess = pred$tab_excess
      )
    } else{
      pred <- lapply(X = 1:nsim, FUN = forecast_sim)
      # Extract and organize results in a list
      res <- list(
        tab_res = do.call("rbind", lapply(1:nsim, function(i){pred[[i]]$tab_res})),
        tab_ex = do.call("rbind", lapply(1:nsim, function(i){pred[[i]]$tab_ex})),
        tab_qx = do.call("rbind", lapply(1:nsim, function(i){pred[[i]]$tab_qx})),
        tab_excess = do.call("rbind", lapply(1:nsim, function(i){pred[[i]]$tab_excess}))
      )
    }
  }
  return(res)
}

