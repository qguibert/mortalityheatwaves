###################################
#' excess_mort : excess of mortality related temperature for past periods
#' @param data_hist a data.frame containing historical data
#' @param model a object containing the fitted DLNM model
#' @param q_range a 2-dimensional vector with the thresholds related to
#' extreme hot and extreme cold temperature
#' @param nsim the number of simulations
#' @param parallel type of parallelization
#' @param ncpus number of cores to use
###################################
excess_mort_dlnm <- function(data_hist, model, q_range = NULL,
                             nsim = 1, parallel = c("no", "snow", "multicore"),
                             ncpus = 1)
{
  #sanity check
  parallel <- match.arg(parallel, c("no", "snow", "multicore"))
  if (parallel == "multicore" & .Platform$OS.type == "windows")
  {
    parallel <- "snow"
    warning("As the multicore option is not supported on Windows it was replaced by snow")
  }
  if ((parallel == "snow" | parallel == "multicore") & missing(ncpus))
    stop("You have to specify the number of available processors to parallelize
         the bootstrap")

  if(! is(model, "list"))
  {
    stop("model should be a list generated by fit_dlnm")
  }

  if(is.null(q_range))
  {
    q_range[1] <- 0
    q_range[2] <- 25
  } else
  {
    if(length(q_range) != 2) stop("q_range should be of length 2")
  }

  n <- length(model)
  age_bucket <- names(model)
  seed <- 12345

  res <- do.call("rbind", lapply(1:n, function(x)
  {
    if(n > 1) # model per age bucket
    {
      temp_model <- model[[x]]
      dem <- data_hist %>% filter(age_bk == age_bucket[x])

      # objects in memory
      vect_import <- c("n", "x", "coef_sim", "temp_model", "dem", "q_range",
                       "dem", "fold_bib")
    } else
    {
      temp_model <- model
      # Demography
      dem <- data_hist
      # objects in memory
      vect_import <- c("n", "coef_sim", "temp_model", "dem", "q_range",
                       "dem", "fold_bib")
    }
    # Compute bootstrapped coefficients
    if (nsim == 1)
    {
      coef_sim <- NULL
    } else
    {
      set.seed(seed + x)
      coef_sim <- mvrnorm(nsim, temp_model$coef, temp_model$vcov)
    }

    # Configure different samples for each effect of temperature
    config_temp <-list(
      all_effect = dem %>% mutate(select_period = 1),
      hot_effect = dem %>% mutate(select_period = 1 * (dem$tavg >  temp_model$cen)),
      cold_effect = dem %>% mutate(select_period = 1 * (dem$tavg <  temp_model$cen)),
      moderate_hot_effect = dem %>% mutate(select_period = 1 * (dem$tavg >  temp_model$cen & dem$tavg <  q_range[2])),
      moderate_cold_effect = dem %>% mutate(select_period = 1 * (dem$tavg <  temp_model$cen & dem$tavg >  q_range[1])),
      extr_hot_effect = dem %>% mutate(select_period = 1 * (dem$tavg >  q_range[2])),
      extr_cold_effect = dem %>% mutate(select_period = 1 * (dem$tavg <  q_range[1]))
    )

    # Function for simulation temperature effects
    pred_effect_sim <- function(i)
    {
      # select coefficient
      if(nsim == 1){
        temp_coef <- coef_sim
      } else{
        temp_coef <- coef_sim[i, ]
      }
      # extract coefs and compute all temperature effects
      pred_effect <- lapply(names(config_temp), function(k)
      {
        df <- config_temp[[k]]
        pred <- predict_attrib_dlnm(temp_model, newdata = df, coef_sim = temp_coef)$pred_effect
        # Agregate results on the populations
        df <- df %>%
          dplyr::select(datedec, age_bk)
        pred <- pred %>%
          left_join(y = df, by = c("datedec")) %>%
          rename(Dxtd = nb_deaths) %>%
          mutate(Dxtd_xs = Dxtd * ewt_contr, temp_effect = k)
        # Agregate by year to reduce size if nsim > 10
        if(nsim > 10)
        {
          pred <- pred %>%
            group_by(years, age_bk, temp_effect) %>%
            summarise(Dxt = sum(Dxtd), Dxt_xs = sum(Dxtd_xs)) %>%
            mutate(attrib_frac = Dxt_xs / Dxt)
        }
        return(pred)
      })
      pred_effect <- do.call("rbind", pred_effect)
      pred_effect$sim <- i
      return(pred_effect)
    }

    # parallel or sequential computation
    if (parallel != "no" && nsim > 1)
    {
      if (parallel == "snow") type.par <- "PSOCK"
      else if (parallel == "multicore") type.par <- "FORK"
      if (parallel == "multicore" & .Platform$OS.type == "windows")
      {
        parallel <- "snow"
        warning("As the multicore option is not supported on Windows it was replaced by snow.")
      }
      clus <- parallel::makeCluster(ncpus, type = type.par)
      parallel::clusterExport(clus, vect_import, envir=environment())
      parallel::clusterEvalQ(clus, {
        source(paste(fold_bib,"predict_attrib_dlnm.R",sep=""), encoding = "UTF-8")
        source(paste(fold_bib,"utils.R",sep=""), encoding = "UTF-8")
        invisible(lapply(c("lubridate", "splines","mgcv", "dlnm", "data.table",
                           "ggplot2","scales","readxl","kableExtra", "dplyr", "tidyr", "mvtnorm", "Rfast",
                           "parallel"), instal.import.package))
      })
      pred <- try(parallel::parLapply(clus, 1:nsim, pred_effect_sim))
      if(!inherits(pred, "try-error"))
      {
        pred <- do.call("rbind", pred)
        pred <- pred %>% relocate(sim, .before = age_bk)
      }
      parallel::stopCluster(clus)
    } else
    {
      if(nsim == 1)
      {
        pred <- data.frame(pred_effect_sim(1))
      } else
      {
        pred <- do.call("rbind",lapply(X = 1:nsim, FUN = pred_effect_sim))
        pred <- pred %>% relocate(sim, .before = age_bk)
      }
    }
    return(pred)
  }))

  # Aggregate by years, temp_effect and age bk
  if(nsim > 10){
    # res_agg and res are equal because we do not calculate the number of death
    # for each day is nsim >10
    res_agg = NULL
    res_mean = NULL
  } else {
    res_agg <- res %>%
      group_by(years, age_bk, temp_effect, sim) %>%
      summarise(Dxt = sum(Dxtd), Dxt_xs = sum(Dxtd_xs)) %>%
      mutate(attrib_frac = Dxt_xs / Dxt)
    # Aggregate age bk and temp_effect
    res_mean <- res %>%
      na.omit() %>%
      group_by(age_bk, temp_effect, sim) %>%
      summarise(Dxt = mean(Dxtd), Dxt_xs = mean(Dxtd_xs),
                attrib_frac = sum(Dxt_xs) / sum(Dxt))
  }

  return(list(excess_mort = res, excess_mort_year = res_agg, avg_attrib_frac = res_mean))
}

